# URL of your slack webhook https://api.slack.com/incoming-webhooks
SLACK_WEBHOOK_URL = ''

# Auth token of your slack bot account https://api.slack.com/bot-users
SLACK_BOT_TOKEN = ''

# Optional mapping of AWS user -> slack user id
# If provided users will get direct messages in addition to notifications sent to a shared slack channel
# SLACK_USER_MAPPINGS = {
#    'example_aws_user': 'IDXXXXXX'
# }

# Data scanned byte threshold above which to send notifications to the user who submitted the query
SLACK_ALERT_DATA_USER_THRESHOLD = 100*1024*1024*1024

# Data scanned byte threshold above which to send notifications to the admin team channel
SLACK_ALERT_DATA_CHANNEL_THRESHOLD = 4 * SLACK_ALERT_DATA_USER_THRESHOLD

# Slack message to be sent
SLACK_MESSAGE = '{user} your last query scanned {data_scanned_gb} GB'

# SQS queue url i.e. https://sqs.us-east-1.amazonaws.com/123456789012/athena-queries - note that you need to specify
# this before that queue has been actually created. If in doubt you can always leave it empty and then update in
# lambda aws console with the created url after cloudformation has run.
SQS_QUEUE_URL = ''

# DynamoDB table name
QUERIES_TABLE = 'athena_queries'

# Optional function which detects and overrides the user name based on query content.
# Some analytical tools (i.e. mode analytics) provide user name in query as a comment
# USER_MAPPING_FUNCTION

# Sample user mapping function for mode analytics:
# def mode_detect_user(query):
#     split = query.rsplit('--', 1)
#     if len(split) == 2:
#         m = re.search('{\"user\":\"([^\"]*)\".*', split[1])
#         return m.group(1) if m is not None else None
# USER_MAPPING_FUNCTION = mode_detect_user
